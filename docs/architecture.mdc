---
description: 
globs: 
alwaysApply: true
---
{alwaysApply: true, globs: ["**/*"]}

# Архитектура MathIDE

## Обзор

MathIDE - система для решения математических задач с использованием GPT и пошагового интерактивного подхода.

## Основные принципы

1. **Модульность** - каждый компонент имеет четко определенную ответственность
2. **Расширяемость** - новые типы преобразований и интерфейсы легко добавляются
3. **Тестируемость** - все компоненты изолированы и покрыты тестами
4. **Переиспользование** - общие утилиты вынесены в отдельные модули

## Структура проекта (ОБНОВЛЕНО ПОСЛЕ РЕФАКТОРИНГА)

```
math-ide/
├── core/                           # Ядро системы
│   ├── engine.py                   # Главный координатор (199 строк)
│   ├── engines/                    # Специализированные компоненты
│   │   ├── transformation_generator.py    # Генерация преобразований (193 строки)
│   │   ├── transformation_applier.py      # Применение преобразований (173 строки)
│   │   ├── solution_checker.py            # Проверка завершённости (131 строка)
│   │   ├── progress_analyzer.py           # Анализ прогресса (90 строк)
│   │   ├── transformation_verifier.py     # Верификация преобразований (88 строк)
│   │   └── branching_analyzer.py          # Анализ ветвящихся решений (107 строк)
│   ├── types.py                    # Типы данных и структуры
│   ├── history.py                  # Управление историей решения
│   ├── gpt_client.py              # Клиент для работы с GPT API
│   ├── parsers.py                 # Парсеры JSON и LaTeX
│   ├── prompts.py                 # Управление промптами
│   └── exceptions.py              # Кастомные исключения
├── interfaces/                     # Пользовательские интерфейсы
│   ├── cli.py                     # Консольный интерфейс
│   ├── telegram_bot.py           # Telegram бот
│   └── telegram/                 # Компоненты Telegram бота
├── prompts/                       # Промпты для GPT
├── tests/                         # Тесты
├── utils/                         # Вспомогательные утилиты
└── docs/                          # Документация
```

## Архитектура ядра (ПОСЛЕ РЕФАКТОРИНГА)

### TransformationEngine - Главный координатор

**Файл:** `core/engine.py` (199 строк)

**Роль:** Координирует работу всех специализированных компонентов

**Компоненты:**
- `TransformationGenerator` - генерация преобразований
- `TransformationApplier` - применение преобразований  
- `SolutionChecker` - проверка завершённости решения
- `ProgressAnalyzer` - анализ прогресса решения
- `TransformationVerifier` - верификация преобразований
- `BranchingAnalyzer` - анализ ветвящихся решений

**Преимущества рефакторинга:**
- ✅ Каждый компонент имеет единственную ответственность
- ✅ Легче тестировать отдельные части системы
- ✅ Проще добавлять новую функциональность
- ✅ Улучшена читаемость кода
- ✅ Сохранена обратная совместимость

### Специализированные компоненты

#### 1. TransformationGenerator
**Файл:** `core/engines/transformation_generator.py` (193 строки)

**Ответственность:** Генерация возможных математических преобразований
- Форматирование промптов для GPT
- Парсинг и валидация JSON ответов
- Сортировка преобразований по полезности
- Поддержка параметризованных преобразований

#### 2. TransformationApplier  
**Файл:** `core/engines/transformation_applier.py` (173 строки)

**Ответственность:** Применение выбранных преобразований
- Подстановка параметров в преобразования
- Выполнение преобразований через GPT
- Валидация результатов
- Обработка ошибок применения

#### 3. SolutionChecker
**Файл:** `core/engines/solution_checker.py` (131 строка)

**Ответственность:** Проверка завершённости решения
- Анализ текущего состояния решения
- Определение степени завершённости
- Классификация типа решения (точное/приблизительное/частичное)
- Предложение следующих шагов

#### 4. ProgressAnalyzer
**Файл:** `core/engines/progress_analyzer.py` (90 строк)

**Ответственность:** Анализ прогресса решения
- Оценка качества продвижения к цели
- Рекомендации по улучшению решения
- Определение необходимости отката
- Анализ эффективности выбранного пути

#### 5. TransformationVerifier
**Файл:** `core/engines/transformation_verifier.py` (88 строк)

**Ответственность:** Верификация корректности преобразований
- Математическая проверка преобразований
- Исправление ошибок в вычислениях
- Пошаговая верификация
- Валидация пользовательского ввода

#### 6. BranchingAnalyzer
**Файл:** `core/engines/branching_analyzer.py` (107 строк)

**Ответственность:** Анализ ветвящихся решений
- Определение необходимости ветвления
- Создание структуры ветвей
- Поддержка различных типов ветвления (системы, случаи, альтернативы)
- Управление сложными решениями

## Потоки данных

### 1. Генерация преобразований
```
SolutionStep → TransformationGenerator → GenerationResult
```

### 2. Применение преобразования  
```
SolutionStep + Transformation → TransformationApplier → ApplyResult
```

### 3. Проверка завершённости
```
SolutionStep + original_task → SolutionChecker → CheckResult
```

### 4. Анализ прогресса
```
task + history + current_step → ProgressAnalyzer → ProgressAnalysisResult
```

### 5. Верификация преобразования
```
original + transformation + result → TransformationVerifier → VerificationResult
```

### 6. Анализ ветвления
```
SolutionStep → BranchingAnalyzer → SolutionStep (with branches)
```

## Типы данных (остались без изменений)

### SolutionStep
Представляет один шаг в решении задачи.

```python
@dataclass
class SolutionStep:
    expression: str
    solution_type: SolutionType = SolutionType.SINGLE
    branches: List[SolutionBranch] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
```

### Transformation
Представляет одно математическое преобразование.

```python
@dataclass
class Transformation:
    description: str
    expression: str
    type: str
    parameters: Optional[List[TransformationParameter]] = None
    parameter_definitions: Optional[List[ParameterDefinition]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    preview_result: Optional[str] = None
    requires_user_input: bool = False
```

### GenerationResult
Результат генерации преобразований.

```python
@dataclass
class GenerationResult:
    transformations: List[Transformation]
```

### ApplyResult
Результат применения преобразования.

```python
@dataclass
class ApplyResult:
    result: str
    is_valid: bool
    explanation: str
    errors: Optional[List[str]] = None
    mathematical_verification: Optional[str] = None
```

### CheckResult
Результат проверки завершённости решения.

```python
@dataclass
class CheckResult:
    is_solved: bool
    confidence: float
    explanation: str
    solution_type: str  # exact, approximate, partial
    next_steps: List[str] = field(default_factory=list)
    mathematical_verification: Optional[str] = None
```

### ProgressAnalysisResult
Результат анализа прогресса решения.

```python
@dataclass
class ProgressAnalysisResult:
    progress_assessment: str  # good, neutral, poor
    confidence: float
    analysis: str
    recommend_rollback: bool
    recommended_step: Optional[int] = None
    rollback_reason: Optional[str] = None
    suggestion_message: Optional[str] = None
```

### VerificationResult
Результат проверки и пересчёта математического преобразования.

```python
@dataclass
class VerificationResult:
    is_correct: bool
    corrected_result: str
    verification_explanation: str
    errors_found: List[str] = field(default_factory=list)
    step_by_step_check: str = ""
    user_result_assessment: Optional[str] = None
```

## Поддержка ветвящихся решений

### SolutionType
Типы решений для поддержки ветвящихся решений.

```python
class SolutionType(Enum):
    SINGLE = "single"           # Одно выражение
    SYSTEM = "system"           # Система уравнений/неравенств
    ALTERNATIVES = "alternatives"  # Альтернативные пути решения
    CASES = "cases"             # Разбор случаев (например, с модулем)
    UNION = "union"             # Объединение решений
    INTERSECTION = "intersection"  # Пересечение решений
```

### SolutionBranch
Представляет одну ветвь решения в ветвящемся решении.

```python
@dataclass
class SolutionBranch:
    id: str
    name: str                   # Название ветви (например, "Случай 1: x ≥ 0")
    expression: str             # Выражение этой ветви
    condition: Optional[str] = None  # Условие для этой ветви
    is_valid: bool = True       # Является ли ветвь валидной
    metadata: Dict[str, Any] = field(default_factory=dict)
```

## Параметризованные преобразования

### ParameterType
Типы параметров преобразований.

```python
class ParameterType(Enum):
    NUMBER = "number"           # Числовое значение
    EXPRESSION = "expression"   # Математическое выражение
    CHOICE = "choice"          # Выбор из предложенных вариантов
    TEXT = "text"              # Произвольный текст
```

### ParameterDefinition
Определение параметра для запроса у пользователя.

```python
@dataclass
class ParameterDefinition:
    name: str                   # Имя параметра (например, "FACTOR")
    prompt: str                 # Текст для запроса у пользователя
    param_type: ParameterType   # Тип параметра
    options: Optional[List[Any]] = None      # Варианты выбора (для CHOICE)
    default_value: Optional[Any] = None      # Значение по умолчанию
    validation_rule: Optional[str] = None    # Правило валидации
    suggested_values: Optional[List[Any]] = None  # Предлагаемые значения
```

### TransformationParameter
Параметр с выбранным значением для использования в преобразовании.

```python
@dataclass
class TransformationParameter:
    name: str
    value: Any
    param_type: ParameterType = ParameterType.TEXT
    original_definition: Optional[ParameterDefinition] = None
```

## Управление историей

### SolutionHistory
Управляет историей решения математической задачи.

**Ключевые возможности:**
- Добавление шагов в историю
- Возврат к произвольному шагу (rollback)
- Экспорт/импорт истории
- Получение сводки по истории

**Методы для работы с откатом:**
- `rollback_to_step(step_number)` - возврат к шагу по номеру
- `rollback_to_step_by_id(step_id)` - возврат к шагу по ID
- `get_current_expression()` - получение текущего выражения
- `can_rollback()` - проверка возможности возврата

## Интерфейсы

### CLI
Консольный интерфейс с поддержкой:
- Отображения математических выражений
- Интерактивного выбора преобразований
- Просмотра истории решения
- Возврата к произвольному шагу
- Ввода параметров для преобразований
- Работы с ветвящимися решениями

### Telegram Bot
Telegram-бот с поддержкой:
- Обработки математических задач
- Красивого рендеринга формул через MathJax
- Интерактивных клавиатур для выбора
- Управления историей решения
- Rate limiting для предотвращения спама

## Промпты

Система использует специализированные промпты для разных задач:

1. **generation.md** - генерация преобразований
2. **apply.md** - применение преобразований
3. **check.md** - проверка завершённости решения
4. **progress_analysis.md** - анализ прогресса
5. **verification.md** - верификация преобразований
6. **branching.md** - анализ ветвящихся решений
7. **transformation_types.md** - описание типов преобразований

## Принципы проектирования (ОБНОВЛЕНО)

### 1. Принцип единственной ответственности (Single Responsibility Principle)
✅ **Выполнен после рефакторинга:** Каждый компонент в `core/engines/` отвечает за одну конкретную задачу.

### 2. Принцип открытости/закрытости (Open/Closed Principle)  
✅ **Выполнен:** Новые типы преобразований можно добавлять без изменения существующего кода.

### 3. Принцип инверсии зависимостей (Dependency Inversion Principle)
✅ **Выполнен:** Компоненты зависят от абстракций (типов), а не от конкретных реализаций.

### 4. Принцип разделения интерфейса (Interface Segregation Principle)
✅ **Улучшен после рефакторинга:** Каждый компонент имеет минимальный и специфичный интерфейс.

### 5. Принцип единственного источника истины (Single Source of Truth)
✅ **Выполнен:** Типы данных определены в одном месте (`core/types.py`).

## Расширяемость (УЛУЧШЕНА ПОСЛЕ РЕФАКТОРИНГА)

### Добавление новых типов преобразований
1. Обновить `BaseTransformationType` в `core/types.py`
2. Добавить примеры в промпт `prompts/transformation_types.md`
3. При необходимости создать специализированный компонент в `core/engines/`

### Добавление новых интерфейсов
1. Создать новый файл в `interfaces/`
2. Использовать `TransformationEngine` как основной API
3. Реализовать специфичные для интерфейса методы отображения

### Добавление новых типов анализа
1. Создать новый компонент в `core/engines/`
2. Добавить соответствующий промпт в `prompts/`
3. Интегрировать в `TransformationEngine` как координатор

## Тестирование

### Архитектурные тесты
- Проверка корректности импортов
- Валидация структуры типов данных
- Тестирование основных сценариев использования

### Модульные тесты
- ✅ Каждый компонент в `core/engines/` можно тестировать изолированно
- ✅ Мокирование GPT API для детерминированных тестов
- ✅ Тестирование различных сценариев ошибок

### Интеграционные тесты  
- Тестирование полных циклов решения задач
- Проверка работы с реальным GPT API
- Валидация работы всех интерфейсов

## Выводы по рефакторингу

### Достигнутые цели:
✅ **Модульность:** Код разбит на логические компоненты  
✅ **Читаемость:** Каждый файл имеет понятную ответственность  
✅ **Тестируемость:** Компоненты изолированы и легко тестируются  
✅ **Расширяемость:** Новую функциональность легко добавлять  
✅ **Обратная совместимость:** Все существующие интерфейсы сохранены  

### Метрики улучшения:
- **Размер основного файла:** 925 → 199 строк (78% сокращение)
- **Количество компонентов:** 1 → 6 специализированных
- **Принцип единственной ответственности:** Полностью соблюдён
- **Цикломатическая сложность:** Значительно снижена

Рефакторинг успешно улучшил архитектуру проекта, сделав код более поддерживаемым и расширяемым.

## Рефакторинг архитектуры (Декабрь 2024)

### Выполненные изменения

**Цель:** Улучшение архитектуры через разбиение монолитного `TransformationEngine` на специализированные компоненты.

### До рефакторинга:
- `core/engine.py`: 925 строк - монолитный класс со множественными ответственностями

### После рефакторинга:
- `core/engine.py`: 199 строк - координатор компонентов
- `core/engines/`: 6 специализированных компонентов (807 строк)
  - `transformation_generator.py` (193 строки)
  - `transformation_applier.py` (173 строки)  
  - `solution_checker.py` (131 строка)
  - `progress_analyzer.py` (90 строк)
  - `transformation_verifier.py` (88 строк)
  - `branching_analyzer.py` (107 строк)

### Достигнутые цели:

✅ **Принцип единственной ответственности**
- Каждый компонент отвечает за одну задачу
- Логически связанный код сгруппирован

✅ **Улучшенная тестируемость**  
- Компоненты изолированы и легко тестируются
- Возможность мокирования отдельных частей

✅ **Повышенная читаемость**
- Основной файл уменьшен на 78%
- Четкая структура ответственностей

✅ **Обратная совместимость**
- Все публичные методы сохранены
- Существующий код продолжает работать

✅ **Расширяемость**
- Новые компоненты легко добавлять
- Модификация одного компонента не влияет на другие

### Архитектурные принципы:

1. **Delegation Pattern**: `TransformationEngine` делегирует задачи специализированным компонентам
2. **Single Responsibility**: Каждый компонент имеет одну ответственность  
3. **Dependency Injection**: Компоненты получают зависимости через конструктор
4. **Interface Segregation**: Минимальные и специфичные интерфейсы

### Метрики улучшения:

| Метрика | До | После | Улучшение |
|---------|-------|--------|-----------|
| Размер основного файла | 925 строк | 199 строк | -78% |
| Количество классов | 1 | 7 | +600% |
| Средний размер компонента | 925 строк | 144 строки | -84% |
| Цикломатическая сложность | Высокая | Низкая | Значительно |

### Влияние на разработку:

**Положительные эффекты:**
- Быстрее локализовать и исправлять ошибки
- Проще добавлять новую функциональность  
- Легче писать и поддерживать тесты
- Улучшено понимание кода новыми разработчиками

**Риски (устранены):**
- ✅ Сохранена обратная совместимость
- ✅ Производительность не пострадала  
- ✅ Все существующие тесты проходят

### Следующие шаги:

1. **CLI рефакторинг**: Разбить `interfaces/cli.py` (549 строк) на компоненты
2. **Web интерфейс**: Реализация задачи 2.2
3. **CI/CD**: Настройка автоматического тестирования (задача 9.3)

Рефакторинг успешно улучшил архитектуру проекта, заложив основу для дальнейшего масштабирования системы. 