---
description: 
globs: 
alwaysApply: false
---
# Архитектура MathIDE

## Обзор проекта

MathIDE - это интеллектуальная система для решения математических задач с использованием GPT. Проект предоставляет несколько интерфейсов (CLI, Telegram бот) для взаимодействия с пользователями и автоматизированного решения математических задач.

## Основные принципы

- **Модульность**: Четкое разделение на ядро, интерфейсы и утилиты
- **Расширяемость**: Возможность добавления новых типов преобразований и интерфейсов
- **Тестируемость**: Покрытие тестами всех критических компонентов
- **Типизация**: Использование аннотаций типов для повышения надежности кода

## Структура проекта

```
math-ide/
├── core/                           # Ядро системы
│   ├── engine.py                   # Главный координатор (288 строк)
│   ├── engines/                    # Специализированные компоненты
│   │   ├── transformation_generator.py    # Генерация преобразований (238 строк)
│   │   ├── transformation_applier.py      # Применение преобразований (192 строки)
│   │   ├── solution_checker.py            # Проверка завершённости (173 строки)
│   │   ├── progress_analyzer.py           # Анализ прогресса (101 строка)
│   │   ├── transformation_verifier.py     # Верификация преобразований (103 строки)
│   │   └── branching_analyzer.py          # Анализ ветвящихся решений (163 строки)
│   ├── types.py                    # Типы данных и структуры
│   ├── history.py                  # Управление историей решения
│   ├── gpt_client.py              # Клиент для работы с GPT API
│   ├── parsers.py                 # Парсеры JSON и LaTeX
│   ├── prompts.py                 # Управление промптами
│   └── exceptions.py              # Кастомные исключения
├── interfaces/                     # Пользовательские интерфейсы
│   ├── cli.py                     # Консольный интерфейс (389 строк)
│   ├── cli_components/            # Компоненты CLI (модульная структура)
│   │   ├── display_manager.py     # Управление отображением (299 строк)
│   │   ├── input_handler.py       # Обработка пользовательского ввода (326 строк)
│   │   ├── latex_renderer.py      # Рендеринг LaTeX (99 строк)
│   │   └── solution_processor.py  # Обработка решения (201 строка)
│   ├── telegram_bot.py           # Telegram бот (главный модуль)
│   └── telegram/                 # Компоненты Telegram бота
│       ├── handlers.py           # Обработчики команд (267 строк)
│       ├── renderers.py          # Рендеринг LaTeX → изображения (242 строки)
│       ├── rate_limiter.py       # Ограничение запросов (122 строки)
│       ├── utils.py              # Утилиты отправки сообщений (82 строки)
│       ├── keyboards.py          # Inline-клавиатуры (80 строк)
│       └── state.py              # Управление состоянием пользователей (58 строк)
├── prompts/                       # Промпты для GPT
├── tests/                         # Тесты (7 файлов)
├── utils/                         # Вспомогательные утилиты
│   ├── math_utils.py             # Математические функции (88 строк)
│   └── logging_utils.py          # Настройка логирования (44 строки)
└── docs/                          # Документация
```

## Ядро системы (core/)

### Основные компоненты

1. **engine.py** - Центральный движок, координирующий работу всех компонентов
2. **engines/** - Специализированные компоненты:
   - `transformation_generator.py` - Генерация преобразований
   - `transformation_applier.py` - Применение преобразований
   - `transformation_verifier.py` - Проверка корректности
   - `solution_checker.py` - Проверка решенности задачи
   - `progress_analyzer.py` - Анализ прогресса решения
   - `branching_analyzer.py` - Анализ ветвления решений

3. **gpt_client.py** - Клиент для взаимодействия с GPT API
4. **history.py** - Управление историей шагов решения
5. **parsers.py** - Парсеры для различных форматов данных
6. **prompts.py** - Управление промптами для GPT
7. **types.py** - Определения типов данных

### Архитектура ядра

Ядро построено по принципу **модульной архитектуры** с четким разделением ответственности:

- **Генерация**: Создание новых преобразований на основе текущего состояния
- **Применение**: Выполнение преобразований над задачей
- **Верификация**: Проверка корректности и обоснованности преобразований
- **Анализ**: Оценка прогресса и качества решения
- **История**: Отслеживание всех изменений с возможностью отката

### Специализированные компоненты

#### 1. TransformationGenerator
**Файл:** `core/engines/transformation_generator.py` (238 строк)

**Ответственность:** Генерация возможных математических преобразований
- Форматирование промптов для GPT
- Парсинг и валидация JSON ответов
- Сортировка преобразований по полезности
- Поддержка параметризованных преобразований

#### 2. TransformationApplier  
**Файл:** `core/engines/transformation_applier.py` (192 строки)

**Ответственность:** Применение выбранных преобразований
- Подстановка параметров в преобразования
- Выполнение преобразований через GPT
- Валидация результатов
- Обработка ошибок применения

#### 3. SolutionChecker
**Файл:** `core/engines/solution_checker.py` (173 строки)

**Ответственность:** Проверка завершённости решения
- Анализ текущего состояния решения
- Определение степени завершённости
- Классификация типа решения (точное/приблизительное/частичное)
- Предложение следующих шагов

#### 4. ProgressAnalyzer
**Файл:** `core/engines/progress_analyzer.py` (101 строка)

**Ответственность:** Анализ прогресса решения
- Оценка качества продвижения к цели
- Рекомендации по улучшению решения
- Определение необходимости отката
- Анализ эффективности выбранного пути

#### 5. TransformationVerifier
**Файл:** `core/engines/transformation_verifier.py` (103 строки)

**Ответственность:** Верификация корректности преобразований
- Математическая проверка преобразований
- Исправление ошибок в вычислениях
- Пошаговая верификация
- Валидация пользовательского ввода

#### 6. BranchingAnalyzer
**Файл:** `core/engines/branching_analyzer.py` (163 строки)

**Ответственность:** Анализ ветвящихся решений
- Определение необходимости ветвления
- Создание структуры ветвей
- Поддержка различных типов ветвления (системы, случаи, альтернативы)
- Управление сложными решениями

## CLI интерфейс (interfaces/cli.py)

### Компоненты CLI

1. **display_manager.py** - Управление отображением в терминале
2. **input_handler.py** - Обработка пользовательского ввода
3. **latex_renderer.py** - Рендеринг LaTeX формул
4. **solution_processor.py** - Обработка решений

### Архитектура CLI

CLI построен как **интерактивное приложение** с поддержкой:
- Пошагового решения задач
- Отображения формул в LaTeX
- Интерактивного выбора действий
- Сохранения и загрузки состояния

### Специализированные CLI компоненты

#### 1. DisplayManager
**Файл:** `interfaces/cli_components/display_manager.py` (299 строк)

**Ответственность:** Управление отображением в CLI
- Отображение математических выражений
- Показ доступных преобразований
- Рендеринг истории решения
- Обработка ошибок и уведомлений

#### 2. InputHandler
**Файл:** `interfaces/cli_components/input_handler.py` (326 строк)

**Ответственность:** Обработка пользовательского ввода
- Валидация пользовательских команд
- Обработка параметров преобразований
- Интерактивные диалоги
- Управление навигацией

#### 3. LatexRenderer
**Файл:** `interfaces/cli_components/latex_renderer.py` (99 строк)

**Ответственность:** Рендеринг LaTeX в CLI
- Преобразование LaTeX в Unicode символы
- Поддержка математических операторов
- Форматирование выражений

#### 4. SolutionProcessor
**Файл:** `interfaces/cli_components/solution_processor.py` (201 строка)

**Ответственность:** Обработка логики решения
- Координация между компонентами
- Управление состоянием решения
- Обработка откатов и истории

## Telegram бот (interfaces/telegram/)

### Компоненты бота

1. **handlers.py** - Обработчики сообщений
2. **keyboards.py** - Инлайн клавиатуры
3. **rate_limiter.py** - Ограничение частоты запросов
4. **renderers.py** - Рендеринг ответов
5. **state.py** - Управление состоянием пользователей
6. **utils.py** - Утилиты для бота

### Архитектура бота

Telegram бот использует **state machine** для управления диалогами:
- Состояния пользователей хранятся в памяти
- Поддержка параллельных сессий
- Rate limiting для защиты от злоупотреблений
- Инлайн клавиатуры для удобного взаимодействия

## Потоки данных

### Основной поток решения задачи

1. **Ввод задачи** → Парсинг и валидация
2. **Анализ текущего состояния** → Определение возможных действий
3. **Генерация преобразований** → Создание новых шагов решения
4. **Применение преобразований** → Выполнение изменений
5. **Верификация** → Проверка корректности
6. **Анализ прогресса** → Оценка продвижения к решению
7. **Проверка завершения** → Определение, решена ли задача

### Детальные потоки данных

#### 1. Генерация преобразований
```
SolutionStep → TransformationGenerator → GenerationResult
```

#### 2. Применение преобразования  
```
SolutionStep + Transformation → TransformationApplier → ApplyResult
```

#### 3. Проверка завершённости
```
SolutionStep + original_task → SolutionChecker → CheckResult
```

#### 4. Анализ прогресса
```
task + history + current_step → ProgressAnalyzer → ProgressAnalysisResult
```

#### 5. Верификация преобразования
```
original + transformation + result → TransformationVerifier → VerificationResult
```

#### 6. Анализ ветвления
```
SolutionStep → BranchingAnalyzer → SolutionStep (with branches)
```

### Обработка ошибок

- **Валидация входных данных** на каждом этапе
- **Graceful degradation** при сбоях GPT API
- **Логирование** всех операций для отладки
- **Откат изменений** при критических ошибках

## Типы данных

### Основные типы

- **Task**: Описание математической задачи
- **Transformation**: Математическое преобразование
- **Solution**: Полное решение задачи
- **History**: История изменений
- **State**: Текущее состояние решения

### Структуры данных

Все типы данных определены в `core/types.py` с использованием:
- **dataclasses** для простых структур
- **TypedDict** для словарей с фиксированными ключами
- **Union** для альтернативных типов
- **Optional** для необязательных полей

### Детальные типы данных

#### SolutionStep
Представляет один шаг в решении задачи.

```python
@dataclass
class SolutionStep:
    expression: str
    solution_type: SolutionType = SolutionType.SINGLE
    branches: List[SolutionBranch] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
```

#### Transformation
Представляет одно математическое преобразование.

```python
@dataclass
class Transformation:
    description: str
    expression: str
    type: str
    parameters: Optional[List[TransformationParameter]] = None
    parameter_definitions: Optional[List[ParameterDefinition]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    preview_result: Optional[str] = None
    requires_user_input: bool = False
```

#### GenerationResult
Результат генерации преобразований.

```python
@dataclass
class GenerationResult:
    transformations: List[Transformation]
```

#### ApplyResult
Результат применения преобразования.

```python
@dataclass
class ApplyResult:
    result: str
    is_valid: bool
    explanation: str
    errors: Optional[List[str]] = None
    mathematical_verification: Optional[str] = None
```

#### CheckResult
Результат проверки завершённости решения.

```python
@dataclass
class CheckResult:
    is_solved: bool
    confidence: float
    explanation: str
    solution_type: str  # exact, approximate, partial
    next_steps: List[str] = field(default_factory=list)
    mathematical_verification: Optional[str] = None
```

#### ProgressAnalysisResult
Результат анализа прогресса решения.

```python
@dataclass
class ProgressAnalysisResult:
    progress_assessment: str  # good, neutral, poor
    confidence: float
    analysis: str
    recommend_rollback: bool
    recommended_step: Optional[int] = None
    rollback_reason: Optional[str] = None
    suggestion_message: Optional[str] = None
```

#### VerificationResult
Результат проверки и пересчёта математического преобразования.

```python
@dataclass
class VerificationResult:
    is_correct: bool
    corrected_result: str
    verification_explanation: str
    errors_found: List[str] = field(default_factory=list)
    step_by_step_check: str = ""
    user_result_assessment: Optional[str] = None
```

## Параметризованные преобразования

### ParameterType
Типы параметров преобразований.

```python
class ParameterType(Enum):
    NUMBER = "number"           # Числовое значение
    EXPRESSION = "expression"   # Математическое выражение
    CHOICE = "choice"          # Выбор из предложенных вариантов
    TEXT = "text"              # Произвольный текст
```

### ParameterDefinition
Определение параметра для запроса у пользователя.

```python
@dataclass
class ParameterDefinition:
    name: str                   # Имя параметра (например, "FACTOR")
    prompt: str                 # Текст для запроса у пользователя
    param_type: ParameterType   # Тип параметра
    options: Optional[List[Any]] = None      # Варианты выбора (для CHOICE)
    default_value: Optional[Any] = None      # Значение по умолчанию
    validation_rule: Optional[str] = None    # Правило валидации
    suggested_values: Optional[List[Any]] = None  # Предлагаемые значения
```

### TransformationParameter
Параметр с выбранным значением для использования в преобразовании.

```python
@dataclass
class TransformationParameter:
    name: str
    value: Any
    param_type: ParameterType = ParameterType.TEXT
    original_definition: Optional[ParameterDefinition] = None
```

## Управление историей

### SolutionHistory
Управляет историей решения математической задачи.

**Ключевые возможности:**
- Добавление шагов в историю
- Возврат к произвольному шагу (rollback)
- Экспорт/импорт истории
- Получение сводки по истории

**Методы для работы с откатом:**
- `rollback_to_step(step_number)` - возврат к шагу по номеру
- `rollback_to_step_by_id(step_id)` - возврат к шагу по ID
- `get_current_expression()` - получение текущего выражения
- `can_rollback()` - проверка возможности возврата

## Принципы проектирования

### SOLID принципы

- **Single Responsibility**: Каждый модуль отвечает за одну область
- **Open/Closed**: Расширение через наследование и композицию
- **Liskov Substitution**: Замена реализаций без изменения интерфейса
- **Interface Segregation**: Тонкие интерфейсы для конкретных задач
- **Dependency Inversion**: Зависимость от абстракций, а не реализаций

### Паттерны проектирования

- **Strategy**: Различные алгоритмы генерации/применения
- **Factory**: Создание объектов через фабрики
- **Observer**: Уведомления об изменениях состояния
- **Command**: Инкапсуляция операций как объектов
- **State**: Управление состояниями в Telegram боте

### Архитектурные принципы

1. **Delegation Pattern**: `TransformationEngine` делегирует задачи специализированным компонентам
2. **Single Responsibility**: Каждый компонент имеет одну ответственность  
3. **Dependency Injection**: Компоненты получают зависимости через конструктор
4. **Interface Segregation**: Минимальные и специфичные интерфейсы

## Расширяемость

### Добавление новых типов преобразований

1. Создать новый класс в `core/engines/`
2. Реализовать интерфейс `TransformationEngine`
3. Добавить промпты в `prompts/`
4. Обновить типы в `core/types.py`
5. Добавить тесты в `tests/`

### Добавление новых интерфейсов

1. Создать модуль в `interfaces/`
2. Реализовать базовый интерфейс
3. Интегрировать с ядром через `core/engine.py`
4. Добавить конфигурацию и тесты

## Тестирование

### Стратегия тестирования

- **Unit тесты**: Покрытие всех критических функций
- **Integration тесты**: Тестирование взаимодействия компонентов
- **End-to-end тесты**: Полные сценарии использования
- **Property-based тесты**: Тестирование инвариантов

### Структура тестов

```
tests/
├── test_engine.py              # Тесты основного движка
├── test_branching.py           # Тесты ветвления
├── test_history_rollback.py    # Тесты отката изменений
├── test_architecture.py        # Тесты архитектурных принципов
└── conftest.py                 # Конфигурация pytest
```

### Архитектурные тесты
- Проверка корректности импортов
- Валидация структуры типов данных
- Тестирование основных сценариев использования

### Модульные тесты
- Каждый компонент в `core/engines/` можно тестировать изолированно
- Мокирование GPT API для детерминированных тестов
- Тестирование различных сценариев ошибок

### Интеграционные тесты  
- Тестирование полных циклов решения задач
- Проверка работы с реальным GPT API
- Валидация работы всех интерфейсов

## Архитектурные принципы

### Принципы разработки

1. **Fail Fast**: Быстрое обнаружение и обработка ошибок
2. **Explicit over Implicit**: Явные зависимости и конфигурация
3. **Composition over Inheritance**: Предпочтение композиции
4. **Separation of Concerns**: Разделение ответственности
5. **Don't Repeat Yourself**: Избежание дублирования кода

### Качество кода

- **Type hints** для всех функций и методов
- **Docstrings** для публичных API
- **Linting** с помощью mypy и flake8
- **Code formatting** с помощью black
- **Pre-commit hooks** для автоматической проверки

## Метрики и мониторинг

### Ключевые метрики

- **Время решения** задач
- **Количество шагов** до решения
- **Успешность** применения преобразований
- **Качество** генерируемых решений
- **Производительность** API запросов

### Логирование

- **Structured logging** для всех операций
- **Different log levels** (DEBUG, INFO, WARNING, ERROR)
- **Context information** в логах
- **Performance metrics** для критических операций

### Метрики архитектуры

| Компонент | Количество модулей | Общий размер |
|-----------|-------------------|--------------|
| Ядро системы | 14 | 1722 строки |
| CLI компоненты | 4 | 925 строк |
| Telegram бот | 7 | 893 строки |
| Утилиты | 3 | 136 строк |
| Тесты | 7 | - |
| **ИТОГО** | **41** | **~3676 строк** |

## Влияние на разработку

### Принятие решений

Архитектура влияет на:
- **Выбор технологий** и библиотек
- **Структуру кода** и организацию файлов
- **Подходы к тестированию** и качеству
- **Процессы разработки** и развертывания

### Эволюция системы

- **Backward compatibility** при изменениях
- **Gradual migration** для крупных изменений
- **Feature flags** для экспериментальных функций
- **Versioning** API и интерфейсов

### Положительные эффекты

**Положительные эффекты:**
- Быстрее локализовать и исправлять ошибки
- Проще добавлять новую функциональность  
- Легче писать и поддерживать тесты
- Улучшено понимание кода новыми разработчиками

**Обеспеченные качества:**
- Обратная совместимость сохранена
- Производительность не пострадала  
- Все существующие тесты проходят
- Принципы SOLID соблюдены во всех модулях
