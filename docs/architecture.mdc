---
description: 
globs: 
alwaysApply: false
---
# Архитектура MathIDE

## Обзор проекта

MathIDE - это интеллектуальная система для решения математических задач с использованием GPT. Проект предоставляет несколько интерфейсов (CLI, Telegram бот) для взаимодействия с пользователями и автоматизированного решения математических задач.

## Основные принципы

- **Модульность**: Четкое разделение на ядро, интерфейсы и утилиты
- **Расширяемость**: Возможность добавления новых типов преобразований и интерфейсов
- **Тестируемость**: Покрытие тестами всех критических компонентов
- **Типизация**: Использование аннотаций типов для повышения надежности кода

## Структура проекта

```
math-ide/
├── core/                           # Ядро системы
│   ├── engine.py                   # Главный координатор (288 строк)
│   ├── engines/                    # Специализированные компоненты
│   │   ├── transformation_generator.py    # Генерация преобразований (238 строк)
│   │   ├── transformation_applier.py      # Применение преобразований (192 строки)
│   │   ├── solution_checker.py            # Проверка завершённости (173 строки)
│   │   ├── progress_analyzer.py           # Анализ прогресса (101 строка)
│   │   └── transformation_verifier.py     # Верификация преобразований (103 строки)
│   ├── types.py                    # Типы данных и структуры
│   ├── history.py                  # Управление историей решения
│   ├── gpt_client.py              # Клиент для работы с GPT API
│   ├── parsers.py                 # Парсеры JSON и LaTeX
│   ├── prompts.py                 # Управление промптами
│   └── exceptions.py              # Кастомные исключения
├── interfaces/                     # Пользовательские интерфейсы
│   ├── cli.py                     # Консольный интерфейс (389 строк)
│   ├── cli_components/            # Компоненты CLI (модульная структура)
│   │   ├── display_manager.py     # Управление отображением (299 строк)
│   │   ├── input_handler.py       # Обработка пользовательского ввода (326 строк)
│   │   ├── latex_renderer.py      # Рендеринг LaTeX (99 строк)
│   │   └── solution_processor.py  # Обработка решения (201 строка)
│   ├── telegram_bot.py           # Telegram бот (главный модуль)
│   └── telegram/                 # Компоненты Telegram бота
│       ├── handlers.py           # Обработчики команд (267 строк)
│       ├── renderers.py          # Рендеринг LaTeX → изображения (242 строки)
│       ├── rate_limiter.py       # Ограничение запросов (122 строки)
│       ├── utils.py              # Утилиты отправки сообщений (82 строки)
│       ├── keyboards.py          # Inline-клавиатуры (80 строк)
│       └── state.py              # Управление состоянием пользователей (58 строк)
├── prompts/                       # Промпты для GPT
├── tests/                         # Тесты (7 файлов)
├── utils/                         # Вспомогательные утилиты
│   ├── math_utils.py             # Математические функции (88 строк)
│   └── logging_utils.py          # Настройка логирования (44 строки)
└── docs/                          # Документация
```

## Ядро системы (core/)

### Основные компоненты

1. **engine.py** - Центральный движок, координирующий работу всех компонентов
2. **engines/** - Специализированные компоненты:
   - `transformation_generator.py` - Генерация преобразований
   - `transformation_applier.py` - Применение преобразований
   - `transformation_verifier.py` - Проверка корректности
   - `solution_checker.py` - Проверка решенности задачи
   - `progress_analyzer.py` - Анализ прогресса решения


3. **gpt_client.py** - Клиент для взаимодействия с GPT API
4. **history.py** - Управление историей шагов решения
5. **parsers.py** - Парсеры для различных форматов данных
6. **prompts.py** - Управление промптами для GPT
7. **types.py** - Определения типов данных

### Архитектура ядра

Ядро построено по принципу **модульной архитектуры** с четким разделением ответственности:

- **Генерация**: Создание новых преобразований на основе текущего состояния
- **Применение**: Выполнение преобразований над задачей
- **Верификация**: Проверка корректности и обоснованности преобразований
- **Анализ**: Оценка прогресса и качества решения
- **История**: Отслеживание всех изменений с возможностью отката

### Специализированные компоненты

#### 1. TransformationGenerator
Генерирует возможные преобразования для текущего математического выражения.

**Вход:** `SolutionStep` (текущее выражение)
**Выход:** `GenerationResult` (список преобразований)

**Основные возможности:**
- Генерация преобразований через GPT
- Поддержка параметризованных преобразований
- Предварительный просмотр результатов (preview_mode)
- Фильтрация по типу и сложности

#### 2. SolutionChecker
**Файл:** `core/engines/solution_checker.py` (173 строки)

**Ответственность:** Проверка завершённости решения
- Анализ текущего состояния решения
- Определение степени завершённости
- Классификация типа решения (точное/приблизительное/частичное)
- Предложение следующих шагов

#### 4. ProgressAnalyzer
**Файл:** `core/engines/progress_analyzer.py` (101 строка)

**Ответственность:** Анализ прогресса решения
- Оценка качества продвижения к цели
- Рекомендации по улучшению решения
- Определение необходимости отката
- Анализ эффективности выбранного пути

#### 5. TransformationVerifier
**Файл:** `core/engines/transformation_verifier.py` (103 строки)

**Ответственность:** Верификация корректности преобразований
- Математическая проверка преобразований
- Исправление ошибок в вычислениях
- Пошаговая верификация
- Валидация пользовательского ввода



## CLI интерфейс (interfaces/cli.py)

### Компоненты CLI

1. **display_manager.py** - Управление отображением в терминале
2. **input_handler.py** - Обработка пользовательского ввода
3. **latex_renderer.py** - Рендеринг LaTeX формул
4. **solution_processor.py** - Обработка решений

### Архитектура CLI

CLI построен как **интерактивное приложение** с поддержкой:
- Пошагового решения задач
- Отображения формул в LaTeX
- Интерактивного выбора действий
- Сохранения и загрузки состояния

### Специализированные CLI компоненты

#### 1. DisplayManager
**Файл:** `interfaces/cli_components/display_manager.py` (299 строк)

**Ответственность:** Управление отображением в CLI
- Отображение математических выражений
- Показ доступных преобразований
- Рендеринг истории решения
- Обработка ошибок и уведомлений

#### 2. InputHandler
**Файл:** `interfaces/cli_components/input_handler.py` (326 строк)

**Ответственность:** Обработка пользовательского ввода
- Валидация пользовательских команд
- Обработка параметров преобразований
- Интерактивные диалоги
- Управление навигацией

#### 3. LatexRenderer
**Файл:** `interfaces/cli_components/latex_renderer.py` (99 строк)

**Ответственность:** Рендеринг LaTeX в CLI
- Преобразование LaTeX в Unicode символы
- Поддержка математических операторов
- Форматирование выражений

#### 4. SolutionProcessor
**Файл:** `interfaces/cli_components/solution_processor.py` (201 строка)

**Ответственность:** Обработка логики решения
- Координация между компонентами
- Управление состоянием решения
- Обработка откатов и истории

## Telegram бот (interfaces/telegram/)

### Компоненты бота

1. **handlers.py** - Обработчики сообщений
2. **keyboards.py** - Инлайн клавиатуры
3. **rate_limiter.py** - Ограничение частоты запросов
4. **renderers.py** - Рендеринг ответов
5. **state.py** - Управление состоянием пользователей
6. **utils.py** - Утилиты для бота

### Архитектура бота

Telegram бот использует **state machine** для управления диалогами:
- Состояния пользователей хранятся в памяти
- Поддержка параллельных сессий
- Rate limiting для защиты от злоупотреблений
- Инлайн клавиатуры для удобного взаимодействия

## Потоки данных

### Основной поток решения задачи

1. **Ввод задачи** → `interfaces/cli.py` или `interfaces/telegram_bot.py`
2. **Генерация преобразований** → `core/engines/transformation_generator.py`
3. **Выбор преобразования** → пользователь через интерфейс
4. **Проверка завершённости** → `core/engines/solution_checker.py`
5. **Анализ прогресса** → `core/engines/progress_analyzer.py`
6. **Отображение результата** → соответствующий интерфейс

### Детальные потоки данных

#### 1. Генерация преобразований
```
SolutionStep → TransformationGenerator → GenerationResult
```

#### 2. Проверка завершённости
```
SolutionStep + original_task → SolutionChecker → CheckResult
```

#### 3. Анализ прогресса
```
task + history + current_step → ProgressAnalyzer → ProgressAnalysisResult
```

#### 4. Верификация преобразования
```
original + transformation + result → TransformationVerifier → VerificationResult
```

#### 5. Анализ ветвления
```

```

### Обработка ошибок

- **Валидация входных данных** на каждом этапе
- **Graceful degradation** при сбоях GPT API
- **Логирование** всех операций для отладки
- **Откат изменений** при критических ошибках

## Типы данных

### Основные типы

- **Task**: Описание математической задачи
- **Transformation**: Математическое преобразование
- **Solution**: Полное решение задачи
- **History**: История изменений
- **State**: Текущее состояние решения

### Структуры данных

Все типы данных определены в `core/types.py` с использованием:
- **dataclasses** для простых структур
- **TypedDict** для словарей с фиксированными ключами
- **Union** для альтернативных типов
- **Optional** для необязательных полей

### Детальные типы данных

#### SolutionStep
Представляет один шаг в решении задачи.

```python
@dataclass
class SolutionStep:
    expression: str
    
    
    metadata: Dict[str, Any] = field(default_factory=dict)
```

#### Transformation
Представляет одно математическое преобразование.

```python
@dataclass
class Transformation:
    description: str
    expression: str
    type: str
    parameters: Optional[List[TransformationParameter]] = None
    parameter_definitions: Optional[List[ParameterDefinition]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    preview_result: Optional[str] = None
    requires_user_input: bool = False
```

#### GenerationResult
Результат генерации преобразований.

```python
@dataclass
class GenerationResult:
    transformations: List[Transformation]
```

#### CheckResult
Результат проверки завершённости решения.

```python
@dataclass
class CheckResult:
    is_solved: bool
    confidence: float
    explanation: str
    solution_type: str  # exact, approximate, partial
    next_steps: List[str] = field(default_factory=list)
    mathematical_verification: Optional[str] = None
```

#### ProgressAnalysisResult
Результат анализа прогресса решения.

```python
@dataclass
class ProgressAnalysisResult:
    progress_assessment: str  # good, neutral, poor
    confidence: float
    analysis: str
    recommend_rollback: bool
    recommended_step: Optional[int] = None
    rollback_reason: Optional[str] = None
    suggestion_message: Optional[str] = None
```

#### VerificationResult
Результат проверки и пересчёта математического преобразования.

```python
@dataclass
class VerificationResult:
    is_correct: bool
    corrected_result: str
    verification_explanation: str
    errors_found: List[str] = field(default_factory=list)
    step_by_step_check: str = ""
    user_result_assessment: Optional[str] = None
```

## Параметризованные преобразования

### ParameterType
Типы параметров преобразований.

```python
class ParameterType(Enum):
    NUMBER = "number"           # Числовое значение
    EXPRESSION = "expression"   # Математическое выражение
    CHOICE = "choice"          # Выбор из предложенных вариантов
    TEXT = "text"              # Произвольный текст
```

### ParameterDefinition
Определение параметра для запроса у пользователя.

```python
@dataclass
class ParameterDefinition:
    name: str                   # Имя параметра (например, "FACTOR")
    prompt: str                 # Текст для запроса у пользователя
    param_type: ParameterType   # Тип параметра
    options: Optional[List[Any]] = None      # Варианты выбора (для CHOICE)
    default_value: Optional[Any] = None      # Значение по умолчанию
    validation_rule: Optional[str] = None    # Правило валидации
    suggested_values: Optional[List[Any]] = None  # Предлагаемые значения
```

### TransformationParameter
Параметр с выбранным значением для использования в преобразовании.

```python
@dataclass
class TransformationParameter:
    name: str
    value: Any
    param_type: ParameterType = ParameterType.TEXT
    original_definition: Optional[ParameterDefinition] = None
```

## Управление историей

### SolutionHistory
Управляет историей решения математической задачи.

**Ключевые возможности:**
- Добавление шагов в историю
- Возврат к произвольному шагу (rollback)
- Экспорт/импорт истории
- Получение сводки по истории

**Методы для работы с откатом:**
- `rollback_to_step(step_number)` - возврат к шагу по номеру
- `rollback_to_step_by_id(step_id)` - возврат к шагу по ID
- `get_current_expression()` - получение текущего выражения
- `can_rollback()` - проверка возможности возврата

## Принципы проектирования

### Специфичные для MathIDE принципы

#### 1. Принцип единственной ответственности в MathIDE
Каждый компонент в `core/engines/` отвечает за одну конкретную задачу:
- `TransformationGenerator` - только генерация преобразований
- `SolutionChecker` - только проверка завершённости
- `ProgressAnalyzer` - только анализ прогресса

#### 2. Принцип открытости/закрытости в MathIDE
Новые типы преобразований добавляются без изменения существующего кода:
- Новые движки в `core/engines/` не влияют на существующие
- Новые интерфейсы в `interfaces/` используют общий API
- Расширение через композицию, а не наследование

#### 3. Принцип инверсии зависимостей в MathIDE
Компоненты зависят от абстракций (типов), а не от конкретных реализаций:
- Все движки используют общие типы из `core/types.py`
- Интерфейсы работают через `TransformationEngine` API
- GPT клиент абстрагирован через интерфейс

#### 4. Принцип разделения интерфейса в MathIDE
Каждый компонент имеет минимальный и специфичный интерфейс:
- CLI компоненты не знают о Telegram боте
- Движки не зависят друг от друга
- Утилиты предоставляют только необходимые функции

#### 5. Принцип единственного источника истины в MathIDE
Типы данных определены в одном месте (`core/types.py`):
- Все компоненты используют одни и те же типы
- Изменения типов автоматически распространяются
- Нет дублирования определений

### Практическое руководство по навигации в коде

#### 🔍 **Где искать функциональность по задачам:**

**Нужно добавить новый тип преобразования?**
- Смотрите `core/engines/transformation_generator.py` - как генерируются преобразования
- Добавляйте новые типы в `core/types.py`

**Нужно изменить логику проверки завершённости решения?**
- Смотрите `core/engines/solution_checker.py` - основная логика проверки
- Смотрите `prompts/check_system.md` и `prompts/check_user.md` - промпты для GPT

**Нужно добавить новый интерфейс (например, Web)?**
- Смотрите `interfaces/cli.py` и `interfaces/telegram_bot.py` - примеры интерфейсов
- Используйте `core/engine.py` как основной API
- Создавайте компоненты по аналогии с `interfaces/cli_components/`

**Нужно изменить отображение в CLI?**
- Смотрите `interfaces/cli_components/display_manager.py` - управление отображением
- Смотрите `interfaces/cli_components/latex_renderer.py` - рендеринг формул

**Нужно добавить новую команду в Telegram бот?**
- Смотрите `interfaces/telegram/handlers.py` - обработчики команд
- Смотрите `interfaces/telegram/keyboards.py` - инлайн клавиатуры
- Смотрите `interfaces/telegram/state.py` - управление состоянием

**Нужно изменить логику анализа прогресса?**
- Смотрите `core/engines/progress_analyzer.py` - анализ прогресса
- Смотрите `prompts/progress_analysis_system.md` и `prompts/progress_analysis_user.md` - промпты для анализа

**Нужно добавить поддержку ветвления решений?**



#### 🔧 **Как работает основной поток решения задачи:**

1. **Ввод задачи** → `interfaces/cli.py` или `interfaces/telegram_bot.py`
2. **Генерация преобразований** → `core/engines/transformation_generator.py`
3. **Выбор преобразования** → пользователь через интерфейс
4. **Проверка завершённости** → `core/engines/solution_checker.py`
5. **Анализ прогресса** → `core/engines/progress_analyzer.py`
6. **Отображение результата** → соответствующий интерфейс

#### 📁 **Структура файлов по назначению:**

**Ядро системы (`core/`):**
- `engine.py` - главный координатор, точка входа для всех интерфейсов
- `engines/` - специализированные движки для разных задач
- `types.py` - все типы данных, используемые в проекте
- `history.py` - управление историей решения с возможностью отката
- `gpt_client.py` - клиент для работы с GPT API

**Интерфейсы (`interfaces/`):**
- `cli.py` - консольный интерфейс
- `cli_components/` - компоненты CLI (отображение, ввод, обработка)
- `telegram/` - компоненты Telegram бота

**Промпты (`prompts/`):**
- Специализированные промпты для каждой задачи
- Изменяйте их для настройки поведения GPT

**Тесты (`tests/`):**
- Тесты для каждого компонента
- Добавляйте тесты при изменении функциональности

## Расширяемость

### Добавление новых типов преобразований

1. Создать новый класс в `core/engines/`
2. Реализовать интерфейс `TransformationEngine`
3. Добавить промпты в `prompts/`
4. Обновить типы в `core/types.py`
5. Добавить тесты в `tests/`

### Добавление новых интерфейсов

1. Создать модуль в `interfaces/`
2. Реализовать базовый интерфейс
3. Интегрировать с ядром через `core/engine.py`
4. Добавить конфигурацию и тесты

## Тестирование

### Стратегия тестирования

- **Unit тесты**: Покрытие всех критических функций
- **Integration тесты**: Тестирование взаимодействия компонентов
- **End-to-end тесты**: Полные сценарии использования
- **Property-based тесты**: Тестирование инвариантов

### Структура тестов

```
tests/
├── test_engine.py              # Тесты основного движка

├── test_history_rollback.py    # Тесты отката изменений
├── test_architecture.py        # Тесты архитектурных принципов
└── conftest.py                 # Конфигурация pytest
```

### Архитектурные тесты
- Проверка корректности импортов
- Валидация структуры типов данных
- Тестирование основных сценариев использования

### Модульные тесты
- Каждый компонент в `core/engines/` можно тестировать изолированно
- Мокирование GPT API для детерминированных тестов
- Тестирование различных сценариев ошибок

### Интеграционные тесты  
- Тестирование полных циклов решения задач
- Проверка работы с реальным GPT API
- Валидация работы всех интерфейсов

## Архитектурные принципы

### Качество кода

- **Type hints** для всех функций и методов
- **Docstrings** для публичных API
- **Linting** с помощью mypy и flake8
- **Code formatting** с помощью black
- **Pre-commit hooks** для автоматической проверки

## Метрики и мониторинг

### Ключевые метрики

- **Время решения** задач
- **Количество шагов** до решения
- **Успешность** применения преобразований
- **Качество** генерируемых решений
- **Производительность** API запросов

### Логирование

- **Structured logging** для всех операций
- **Different log levels** (DEBUG, INFO, WARNING, ERROR)
- **Context information** в логах
- **Performance metrics** для критических операций

### Метрики архитектуры

| Компонент | Количество модулей | Общий размер |
|-----------|-------------------|--------------|
| Ядро системы | 14 | 1722 строки |
| CLI компоненты | 4 | 925 строк |
| Telegram бот | 7 | 893 строки |
| Утилиты | 3 | 136 строк |
| Тесты | 7 | - |
| **ИТОГО** | **41** | **~3676 строк** |

## Влияние на разработку

### Эволюция системы

- **Backward compatibility** при изменениях
- **Gradual migration** для крупных изменений
- **Feature flags** для экспериментальных функций
- **Versioning** API и интерфейсов
