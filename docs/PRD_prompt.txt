Я хочу сделать прототип программы (я называю её MathIDE), которая будет помогать ученику решать математические уравнения.
Основная идея заключается в том, что пользователь (ученик) шаг за шагом решает задачу. MathIDE называется IDE, потому что даёт возможности «автокомплита», разрешающего пользователю выполнять только допустимые операции из списка и предлагающего приоритезированный по актуальности список таких операций. Выбранные операции выполняет не ученик, а сама IDE. Пользователь не учится выполнять операции, но учится самостоятельно строить план того, какие операции выполнить следует.
Пользователь присылает уравнение, которое хочет решить. MathIDE помогает ему шаг за шагом преобразовывать уравнение, пока пользователь не придёт к финальному ответу или не захочет прерваться.
MathIDE не пытается решить уравнение самостоятельно, поскольку эта система предназначена для обучения и должна тренировать пользователя самостоятельно выбирать подходящие действия. Вместо этого он составляет список того, какие корректные преобразования (или другие действия) в принципе можно совершить с уравнением.
MathIDE ранжирует свои предложения о какие преобразования допустимо сделать с уравнением по степени их полезности и осмысленности. Топ-5 предложений перемешивает и выводит пользователю, чтобы он выбрал одно из них.
Пользовтель совершает выбор, после чего MathIDE должен самостоятельно применить к этому уравнению (или к уравнению на одном из прошлых шагов) выбранное преобразование и показать пользователю результат. Далее он снова подбирает подходящие преобразования с этим новым уравнением. Эта последовательность действий повторяется происходит, пока пользователь не придёт к конечному ответу.
Пользователь должен видеть исходное уравнение, цепочку проведённых преобразований и промежуточных результатов, иметь возможность вернуться к одному из более ранних шагов.
В будущих версиях MathIDE (начиная с 1.1) вместе с допустимыми преобразованиями сразу показывает и результат применения каждого преобразования (предпоказ). Этот режим должен быть конфигурируемым.
В версии 1.2 преобразования могут иметь параметры, которые MathIDE интерактивно запрашивает у пользователя (например, множитель для домножения). Пользователь выбирает или вводит параметр, после чего преобразование применяется с этим значением.
В версии 1.3 пользователь может вводить собственные преобразования и значения параметров. В этом случае предпоказ результата невозможен.
В версии 1.4 пользователь может вернуться к произвольному этапу истории через интерфейс.
Иногда бывает так, что одно уравнение превращается сразу в несколько (например, в систему уравнений или в альтернативный выбор уравнений). В таком случае MathIDE должна показать в качестве промежуточного результата сразу все уравнения (в том числе те, которые не поменялись с прошлого шага). Предложения о преобразованиях, которые MathIDE предлагает, должны касаться всей совокупности уравнений.
Для того, чтобы сгенерировать список подходящих преобразований, выполнить выбранное преобразование или проверить, решена ли задача, MathIDE совершает запрос к OpenAI ChatGPT (к одной из дешёвых моделей). Токен доступа к API у меня есть.
Формулы должны отображаться в LaTeX. В средах, в которых это возможно, формулы должны быть отрендерены.
В коде должна быть заложена возможность легко переключиться на другие GPT-модели (в частности, qwen).
Должно быть несколько способов общения пользователя с системой:
— в терминале
— в телеграм-боте (формулы в телеграм-интерфейсе должны рендериться в виде картинок)
— в браузере
Хочу, чтобы ядро системы было максимально простым, но не теряющим расширяемости.
Промпты для запросов к GPT-модели должны быть вынесены в место, в котором разработчику их легко будет отформатировать.
Разворачивать систему я буду на собственном VPS-сервере.
В качестве языка программирования, следует использовать Python.


Сформируй следующие документы:
### Техническое задание (project requirements document) в файле `docs/PRD.mdc`

Используемый формат — Markdown Cursor Rules. В файле должны быть следующие разделы:
1. Overview / Problem
2. Key User Flows
3. Functional Requirements
4. Non-goals
5. Milestones & Release Plan

### Технический стек `.cursor/rules/technical_stack.mdc`
Документ сделай в формате markdown-таблицы. Для каждого слоя приложения отрази следующую информацию: библиотека или сервис, номер версии, зачем слой нужен, ссылка на официальную документацию. Список необходимых компонент сформируй самостоятельно.
В заголовке mdc-файла отрази `{alwaysApply: true, globs: ["**/*"]}` и другие директивы, которые считаешь оптимальными в качестве директив для cursor rules.

## Описание структуры проекта `.cursor/rules/project_structure.mdc`
Сгенерируй его в виде markdown-документа с несколькими таблицами или разделами:
* структура: папка + её назначение
* главные файлы: имя файла + его назначение
* раздел «Генерируй новые файлы здесь» со списком папок, куда Cursor может добавлять код
Также отрази в файле рекомендуемые диркетивы cursor rules.

### Подробный план разработки `docs/implementation_details.mdc`

План разработки должен быть разбит на этапы от MVP до финального продукта. В рамках каждого этапа задачи должны быть разбиты на компоненты. У каждой задачи должен быть статус выполнения.
По мере работы Cursor должен отмечать статус выполнение каждой из задач. 
Перед тем, как приступать к выполнению задачи, Cursor может доопределить задачу. По окончании выполнения задачи, Cursor должен помимо статуса выполнения отметить, что именно было сделано в её рамках и выписать обнаруженные проблемы, касающиеся этой задач, если такие есть и не могут быть исправлены на данном этапе. Если проблемы могут быть исправлены, исправь. Также в процессе написания программы могут появиться новые подзадачи. Важно, что Cursor не может изменить набор исходных задач и их формулировки, он может лишь дописать комментарии к ним; причём должно быть понятно, где исходное описание, а где дополнения, выполненные в процессе работы.
В плане разработки в рамках каждого этапа должны быть прописаны критерии приёмки выполнения задачи в форме чеклиста требуемых проверок. Статусы прохождения этих проверок должны быть заполнены после выполнения этапа. Этап не может быть завершен, пока все проверки не были пройдены. Если они не пройдены, Cursor должен дописать раздел дополнительных задач этапа, которые должны быть завершены для того, чтобы проверки могли быть выполнены.
Также дополни план разработки списком часто встречающихся проблем с кодом, которых Cursor должен избежать.
Не забудь отразить в файле рекомендуемые директивы cursor rules.

### Описание процессов реализации `.cursor/rules/implementation_flow.mdc`

Опиши в документе cursor rules, которые описывают лучшие практики написания кода в Cursor. Прошу проконтроллировать, что:
* задачи выполняются по одной
* выполнение каждой задачи должно завершаться созданием коммита с описанием проделанной работы.
* весь код должен быть документирован. Также должна быть документация проекта как единого целого.
